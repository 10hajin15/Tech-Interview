## CHAPTER 09. 비동기 프로그래밍 패턴
### 9.1 비동기 프로그래밍
- 자바스크립트에서 동기 코드는 블로킹 방식으로 실행된다.
- 비동기 코드는 논블로킹 방식으로 실행된다.
```javascript
// (1) 동기 코드
function synchronousFunction() {
  // 동기 함수 동작
}

synchronousFunction();
// -- 이 줄이 오기 전에 함수 내부의 코드를 실행 --

// (2) 비동기 코드
function asynchronousFunction() {
  // 비동기 함수 동작
}

asynchronousFunction();
// -- 함수 내부의 코드는 백그라운드에서 실행되며 이 줄로 제어권을 반환 --
```

- 비동기 코드는 일반적으로 코드의 나머지 부분을 차단하지 않고 오래 실행되는 작업을 수행할 때 유용하다.

``` javascript
// (1) 콜백 사용 예시
function makeRequest(url, callback) {
  fetch(url)
    .then(response => response.json())
    .then(data => callback(data))
    .catch(error => callback(error));
}

makeRequest('http://example.com', (error, data) => {
  if (error) {
    console.error(error);
  } else {
    console.log(data);
  }
});

// (2) promise 사용 예시
function makeRequest(url) {
  return new Promise((resolve, reject) => {
    fetch(url)
      .then(response => response.json())
      .then(data => resolve(data))
      .catch(error => reject(error));
  });
}

makeRequest('http://example.com')
  .then(data => console.log(data))
  .catch(error => console.error(error));

// (3) async/await 사용 예시
async function makeRequest(url) {
  try {
    const response = await fetch(url);
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error(error);
  }
}

makeRequest('http://example.com');
```

### 9.2 배경
- 자바스크립트에서 콜백 함수는 다른 함수에 인수로서 전달되어, 비동기 작업이 완료된 후 실행된다.
- 콜백을 사용할 때의 주요 단점 중 하나는 '콜백 지옥'
- '콜백 지옥': 중첩된 콜백 구조로 인해 코드의 가독성과 유지보수성이 크게 저하되는 상황

### 9.3 프로미스 패턴
- 프로미스는 자바스크립트에서 비동기 작업을 처리하는 최신 방법이다.
- 프로미스는 비동기 작업의 결과를 나타내는 객체로, 대기(pending) & 완료(fulfilled) & 거부(rejected)의 세 가지 상태를 가진다.
- 프로미스의 장점은 콜백보다 체계적이고 가독성이 높은 방법으로 비동기 작업을 처리할 수 있다는 점이다.

**9.3.1 프로미스 체이닝**
- 프로미스 체이닝 패턴을 사용하면 여러 개의 프로미스를 함께 연결하여 보다 복잡한 비동기 로직을 만들 수 있다.
```javascript
function makeRequest(url) {
  return new Promise((resolve, reject) => {
    fetch(url)
      .then(response => response.json())
      .then(data => resolve(data))
      .catch(error => reject(error));
  });
}

function procesesData(data) {
  // process data
  return processedData;
}

makeRequest('http://example.com')
  .then(data => processData(data))
  .then(processedData => console.log(processedData))
  .catch(error => console.error(error));
```

**9.3.2 프로미스 에러 처리**
- 프로미스 에러 처리 패턴은 `catch` 메서드를 사용하여 프로미스 체인의 실행 중에 발생할 수 있는 에러를 처리한다.

**9.3.3 프로미스 병렬 처리**
- `Promise.all` 메서드를 사용하여 여러 프로미스를 동시에 사용할 수 있다.
```javascript
Promise.all([
  makeRequest('http://example.com/1'),
  makeRequest('http://example.com/2')
]).then(([data1, data2]) => {
  console.log(data1, data2);
});
```
- `Promise.all`은 배열 중 하나라도 작업이 reject 당하면 바로 catch로 가버린다. 그래서 등장한 `Promise.allSettled`!
- `Promise.allSettled`는 병렬적으로 처리하되, 하나라도 실패해도 무조건 이행한다.
- 반환값은 프로미스들 결과를 배열로 리턴한다.

**9.3.4 프로미스 순차 실행**
- `Promise.resolve` 메서드를 사용하여 프로미스를 순차적으로 실행할 수 있게 한다.
```javascript
Promise.resolve()
  .then(() => makeRequest1())
  .then(() => makeRequest2())
  .then(() => makeRequest3())
  .then(() => {
    // 모든 요청 완료
  });
```

**9.3.5 프로미스 메모이제이션**
- 프로미스 메모이제이션 패턴은 캐시를 사용하여 프로미스 함수 호출의 결과 값을 저장한다.
- 중복된 요청을 방지
```javascript
const cache = new Map();

function memoizedMakeRequest(url) {
  if (cache.has(url)) {
    return cache.get(url);
  }
  
  return new Promise((resolve, reject) => {
    fetch(url)
      .then(response => response.json())
      .then(data => {
        cache.set(url, data);
        resolve(data);
      })
      .catch(error => reject(error));
  });
}

// 사용 예제
const button = document.querySelector('button');
button.addEventListener('click', () => {
  memoizedMakeRequest('http://example.com')
    .then(data => console.log(data))
    .catch(error => console.error(error))
});
```

**9.3.6 프로미스 파이프라인**
- 프로미스 파이프라인 패턴은 프로미스와 함수형 프로그래밍 기법을 활용하여 비동기 처리의 파이프라인을 생성한다.
```javascript
function transform1(data) {
  // 데이터 변환
  return transformedData;
}

function transform2(data) {
  // 데이터 변환
  return transformedData;
}

makeRequest('http://example.com')
  .then(data => pipeline(data)
    .then(transform1)
    .then(transform2))
  .then(transformedData => console.log(transformedData))
  .catch(error => console.error(error));
```

**9.3.7 프로미스 재시도**
- 프로미스가 실패할 때 다시 시도할 수 있다.
```javascript
function makeRequestWithRetry(url) {
  let attempts = 0;
  
  const makeRequest = () => new Promise((resolve, reject) -> {
    fetch(url)
      .then(response => response.json())
      .then(data => resolve(data))
      .catch(error => reject(error));
  });

  const retry = error => {
    attempts++;
    if (attempts >= 3) {
      throw new Error('Request failed after 3 attempts.');
    }
    console.log(`Retrying request: attempt ${attempts}`);
    return makeRequest();
  };

  return makeRequest().catch(retry);
}
```

**9.3.8 프로미스 데코레이터**
- 고차 함수를 사용하여 프로미스에 적용할 수 있는 데코레이터를 생성한다.
- 이를 통해 프로미스에 추가적인 기능을 부여할 수 있다.
```javascript
funtion logger(fn) {
  return function (...args) {
    console.log('Starting function...');
    return fn(...args).then(result => {
      console.log('Function completed.');
      return result;
    });
  };
}

const makeRequestWithLogger = logger(makeRequest);

makeRequestWithLogger('http://example.com')
  .then(data => console.log(data))
  .catch(error => console.error(error));
```

**9.3.9 프로미스 경쟁**
- 여러 프로미스를 동시에 실행하고 가장 먼저 완료되는 프로미스의 결과를 반환
```javascript
Promise.race([
  makeRequest('http://example.com/1')
  makeRequest('http://example.com/2')
]).then(data => {
  console.log(data);
});
```

### 9.4 async/await 패턴
- async/await는 프로미스를 기반으로 구축되었으며, 비동기 코드 작업을 보다 쉽고 간결하게 만들어준다.

**9.4.1 비동기 함수 조합**
- 여러 비동기 함수를 조합하여 보다 복잡한 비동기 로직을 구성하는 것
```javascript
async function makeRequest(url) {
  const response = await fetch(url);
  const data = await response.json();
  return data;
}

async function processData(data) {
  // 데이터 처리
  return processedData;
}

async function main() {
  const data = await makeRequest('http://example.com');
  const processedData = await processData(data);
  console.log(processedData);
}
```

**9.4.2 비동기 반복**
- `for-await-of`
```javascript
async function* createAsyncIterable() {
  yield 1;
  yield 2;
  yield 3;
}

async function main() {
  for await(const value of createAsyncIterable()) {
    console.log(value);
  }
}
```

**9.4.3 비동기 에러 처리**
- `try-catch` 사용

**9.4.4 비동기 병렬**
- `Promise.all` 사용
```javascript
async function main() {
  const [data1, data2] = await Promise.all([
    makeRequest('http://example.com/1'),
    makeRequest('http://example.com.2')
  ]);
  
  console.log(data1, data2);
}
```

**9.4.5 비동기 순차 실행**
- `Promise.resolve` 메서드 사용

**9.4.6 비동기 메모이제이션**
- 캐시를 사용해 비동기 함수 호출 결과를 저장하여 중복 요청 방지

**9.4.7 비동기 이벤트 처리**
- 비동기 함수를 사용하여 이벤트를 처리할 수 있도록 한다.

**9.4.8 async/await 파이프라인**
- async/await와 함수형 프로그래밍 기법을 활용하여 비동기 변환 작업들의 파이프라인을 생성한다.
```javascript
async function transform1(data) {
  // 변형된 데이터 반환
  return transformedData;
}

async function transform2(data) {
  // 변형된 데이터 반환
  return transformedData;
}

async function main() {
  const data = await makeRequest('http://example.com');
  const transformedData = await pipeline(data)
    .then(transform1)
    .then(transform2);
  
  console.log(transformedData);
}
```

**9.4.9 비동기 재시도**
- 비동기 작업이 실패해도 자동으로 재시도 할 수 있다.

**9.4.10 async/await 데코레이터**
- 고차함수를 사용하여 데코레이터를 생성한다.
```javascript
function asyncLogger(fn) {
  return async function(...args) {
    console.log('Starting async function...');
    const result = await fn(...args);
    console.log('Async function completed.');
    return result;
  };
}

@asyncLogger
async function main() {
  const data = await makeRequest('http://example.com');
  console.log(data);
}
```

### 9.5 실용적인 예제 더보기
- HTTP 요청 보내기
- 파일 시스템에서 파일 읽기/쓰기
- 여러 비동기 함수를 한 번에 실행하기
- 여러 비동기 함수를 순서대로 실행하기
- 함수의 결과를 캐싱하기
- async/await로 이벤트 처리하기
- 비동기 함수 실패 시 자동으로 재시도하기
- async/await 데코레이터 작성하기

### 내 생각 💭
비동기 작업을 처리할 수 있는 여러 방법들을 정리할 수 있어 좋았다.
`Promise`와 `async/await`은 직접 구현해보며 동작 방식을 더 깊게 이해해보고자 한다!
또한, TS 데코레이터 패턴을 처음 알게되었는데 좀 더 공부를 해서 유용하게 써봐야겠다!!
