## CHAPTER 08. 자바스크립트 MV* 패턴
### 8.1 MVC 패턴
애플리케이션의 구조를 개선하기 위해 관심사의 분리를 활용하는 아키텍처 디자인 패턴

비즈니스 데이터(모델)과 UI(뷰)를 분리하고, 세 번째 구성 요소(컨트롤러)가 로직과 사용자 입력을 관리하는 구조

**8.1.1 Smalltalk-80의 MVC 패턴**
- Smalltalk-80에서 구현된 MVC는 '분리된 프레젠테이션' 개념을 한 단계 더 발전시킨 애플리케이션의 로직과 UI를 분리하는 것을 목표로 함

📣 분리된 프레젠테이션: 실제 세계의 아이디어(예: 사진, 사람)를 모델링하는 도메인 객체와 사용자의 화면에 렌더링되는 프레젠테이션 객체 사이를 명확하게 구분하기 위한 수단

|-|-|
|--|--|
|모델|도메인 관련 데이터를 표현하며 UI(뷰와 컨트롤러)에 대해서는 관여하지 않는다. 모델이 변경되면 자신의 관찰자(observer)객체에 알림을 보낸다.
|뷰|모델의 현재 상태를 표현한다. 관찰자 패턴을 사용해 모델이 변경되거나 수정될 때마다 뷰가 알아차릴 수 있도록 한다. 또한 뷰는 화면에 보여지는 프레젠테이션 부분만을 담당했지만, 화면에 표시되는 각 섹션 또는 요소에는 언제나 뷰-컨트롤러 쌍이 존재한다.|
|컨트롤러|키보드 입력이나 클릭 같은 사용자의 상호작용을 처리하고 뷰에 무엇을 보여줄지, 사용자 입력을 어떻게 처리할지 등을 결정하는 역할을 한다.|

### 8.2 자바스트립트의 MVC
![](https://velog.velcdn.com/images/oazin15/post/b47c5120-cfb9-437d-9610-5ba2b7f65e84/image.png)

**8.2.1 모델**

모델은 애플리케이션의 데이터를 관리하는 역할을 한다. UI나 프레젠테이션 계층은 담당하지 않고, 애플리케이션에 필요한 고유 데이터 형식을 나타낸다.
- MVC/MV* 프레임워크에서는 모델을 컬렉션으로 그룹화하는 기능을 제공하는 경우가 많다. 모델을 그룹으로 관리하면 그룹 내의 특정 모델이 변경될 때 그룹의 알림을 기반으로 로직을 작성할 수 있어, 개별 모델 인스턴스를 직접 관찰할 필요가 없다.

**8.2.2 뷰**

모델에 대한 시각적인 표현으로, 현재 상태의 특정 부분만 보여준다. 자바스크립트의 뷰는 여러 DOM 요소의 집합을 생성하고 정리하는 역할을 한다.
- 뷰는 모델을 관찰하고, 모델에 변화가 생기면 알림을 받는다. 이를 통해 뷰는 스스로를 업데이트할 수 있다.
``` javascript
const buildPhotoView = (photoModel, photoController) => {
  const base = document.createElement('div');
  const photoEl = document.createElement('div');
  
  base.appendChild(photoEl);
  
  const render = () => {
    // 사진 항목에 대한 HTML을 생성하기 위해
    // Lodash의 템플릿 메서드를 사용
    photo entry
    photo.innerHTML = _.template('#photoTemplate', {
      src: photoModel.getSrc()
    });
  };
  
  photoModel.addSubscriber(render);
  
  photoEl.addEventListener('click', () => {
    photoController.handleEvent('click', photoModel);
  });
  
  const show = () => {
    photoEl.style.display = '';
  };
  
  const hide = () => {
    photoEl.style.display = 'none';
  };
  
  return {
    showView: show,
    hideView: hide
  };
};
```

**8.2.3 템플릿**
- 문자열의 연결을 통해 메모리에 큰 HTML 마크업 블록을 수동으로 생성하는 것은 성능적으로 나쁜 작업으로 오랫동안 간주되어 왔다.
- ES6에 등장한 태그 템플릿 리터럴을 사용하면 자바스크립트의 템플릿 리터럴 문법과 함께 템플릿을 조작하고 데이터를 채우는 데 사용할 수 있는 커스텀 처리 함수를 통해 재사용 가능한 템플릿을 만들 수 있다.

```javascript
// (1) 태그 템플릿 리터럴 코드
const photos = [
  {
    caption: 'Sampla Photo 1',
    src: 'photo1.jpg',
    metadata: 'Some metadata for photo 1',
  },
  {
    caption: 'Sample Photo 2',
    src: 'photo2.jpg',
    metadata: 'Some metadata for photo 2',
  },
];

// 태그 템플릿 리터럴을 위한 함수
function photoTemplate(strings, caption, src, metadata) {
  return strings[0] + caption + strings[1] + src + strings[2] + metadata + strings[3];
}

// 태그 템플릿 리터럴 문자열로 템플릿 정의
const template = (caption, src, metadata) => photoTemplate`<li class='photo'>
	<h2>${caption}</h2>
	<img class='source' src='${src}' />
	<div class='metadata'>
		${metadata}
	</div>
</li>`;

// 데이터를 돌며 템플릿을 추가
const photoList = document.createElement('ul');
photos.forEach((photo) => {
  const photoItem = template(photo.caption, photo.src, photo.metadata);
  photoList.innerHTML += photoItem;
});

// DOM에 만들어진 템플릿 추가
document.body.append(photoList);
```

```javascript
// (2) Lodash 템플릿
<li class='photo'>
  <h2><%- caption %></h2>
  <img class='source' src='<%- src %>'/>
  <div class='metadata'>
    <%- metadata %>
  </div>
</li>
```
- 템플릿 자체가 뷰는 아니다!!
- 뷰는 애플리케이션 데이터를 시각적으로 표현하고, 템플릿은 뷰를 생성하기 위해 사용될 수 있다.

**8.2.4 컨트롤러**

컨트롤러는 모델과 뷰 사이의 중재자 역할을 하며, 일반적으로 사용자가 뷰를 조작할 때 모델을 업데이트하는 역할을 한다.

### 8.3 MVC를 사용하는 이유는?

① **전반적인 유지보수의 단순화**: 애플리케이션을 업데이트해야 할 때, 변경사항이 데이터 중심인지(모델과 컨트롤러의 변경) 아니면 단순히 시각적인 변경인지(뷰의 변경) 명확하게 구분할 수 있다.

② **모델과 뷰의 분리**: 비즈니스 로직에 대한 단위 테스트의 작성이 훨씬 간편해진다.

③ 애플리케이션 전반에서 하위 수준의 모델 및 컨트롤러 코드 중복이 제거된다.

④ 애플리케이션의 규모와 역할의 분리 정도에 따라, 모듈화를 통해 코어 로직을 담당하는 개발자나 UI 작업을 담당하는 개발자가 동시에 작업할 수 있다.

### 8.4 자바스크립트와 Smalltalk-80의 MVC
⦿ MVC의 또 다른 관점
- GoF는 MVC를 디자인 패턴으로 언급하지 않고 UI를 구축하기 위한 클래스의 집합으로 간주한다.
- GoF의 관점에서 MVC는 관찰자, 전략, 컴포지트의 세 가지 전통적인 디자인 패턴의 변형이다.

### 8.5 MVC 정리
- 새로운 자바스크립트 MVC/MV* 프레임워크를 검토할 때는, 한 걸음 물러서서 프레임워크의 아키텍처 접근 방식을 살펴보는 것이 유용할 수 있다.

### 8.6 MVP 패턴
- MVP 패턴은 프레젠테이션 로직의 개선에 초점을 맞춘 MVC 디자인 패턴의 파생이다.

**8.6.1 모델, 뷰, 프리젠터**
- MVP에서 P는 프리젠터를 의미하며, 뷰에 대한 UI 비즈니스 로직을 담당하는 구성 요소이다.
![](https://velog.velcdn.com/images/oazin15/post/4397173c-9666-4d8d-87f5-b18d32dc87f6/image.png)
- P는 뷰의 요청에 따라, 사용자 요청과 관련된 작업을 수행하고 데이터를 뷰로 다시 전달한다.
- 이를 위해 프리젠터는 데이터를 가져오고, 조작하고, 이 데이터가 어떻게 뷰에 표시되어야 하는지 결정한다.
- 모델이 이벤트를 발생시킬 수도 있지만, 이벤트를 구독하여 뷰를 업데이트할 수 있도록 하는 것이 프리젠터의 역할이다.
- 이러한 수동형 아키텍처에서는 직접적인 데이터 바인딩의 개념이 없다.
→ 대신 뷰는 프리젠터가 데이터를 설정하는 데 사용할 수 있는 세터를 제공

**8.6.2 MVP vs MVC**

① MVP는 일반적으로 프레젠테이션 로직을 최대한 재사용해야 하는 엔터프라이즈 수준의 애플리케이션에서 사용된다.
- 뷰가 매우 복잡하고 사용자와 상호작용이 많은 애플리케이션에서 MVC 패턴을 사용하게 되면 여러 컨트롤러에 크게 의존해야 할 수 있기 때문에 적합하지 않을 수 있다.
- MVP에서는 이 모든 복잡한 로직을 프리젠터 안에 캡슐화할 수 있어 유지보수가 훨씬 간단해진다.

② MVP 패턴을 사용하면 개발자는 디자이너를 기다리지 않고 프레젠테이션 로직을 작성할 수 있다.
- MVP의 뷰는 인터페이스를 통해 정의되고, 인터페이스가 시스템과 뷰(프리젠터 제외) 간의 유일한 접점이므로 뷰와 관련없이 프레젠테이션 로직은 미리 짤 수 있다.

③ MVP는 구현 방식에 따라 MVC보다 단위 테스트가 더 쉬울 수 있다.
- 프리젠터를 UI의 완전한 모킹으로 사용하여 다른 구성 요소와 독립적으로 단위 테스트를 할 수 있기 때문이다. (이러한 차이는 MVP를 구현하는 개발 언어의 영향이 크다!)

> - MVC와 MVP 간의 차이점이 대부분 의미론적인 수준이므로, MVC에 존재하는 근본적인 문제점들은 MVP에도 동일하게 존재할 가능성이 크다.
> - 많은 자바스크립트 개발자는 MVC와 MVP를 상호 배타적인 것으로 보지 않는다. 왜냐하면 애플리케이션에 프리젠터/뷰 로직을 추가하더라도 여전히 MVC 패턴의 한 종류로 여길 수 있기 때문이다.

### 8.7 MVVM 패턴
MVVM 패턴은 MVC와 MVP를 기반으로 하는 아키텍처 패턴으로, 애플리케이션의 UI 개발 부분과 비즈니스 로직, 동작 부분을 명확하게 분리한다.
- 많은 MVVM의 구현 방식은 선언적 데이터 바인딩을 활용하여 뷰에 대한 작업을 다른 계층과 분리할 수 있도록 한다.

![](https://velog.velcdn.com/images/oazin15/post/108c3df8-9097-4c9d-b7e4-c2096673d172/image.png)

**8.7.1 역사**

|-|-|
|--|--|
|모델|도메인에 관련된 정보를 전달한다.|
|뷰|사용자 인터페이스(UI)|
|뷰모델|모델과 뷰 사이의 인터페이스 역할을 한다.|

**8.7.2 모델**
- 다른 MV* 패턴들과 마찬가지로, MVVM의 모델은 애플리케이션이 사용할 도메인 관련 데이터나 정보를 제공한다.
- 모델은 보통 정보를 담고 있지, 동작을 다루지 않는다.
- 모델의 역할 중 유일한 예외는 데이터 유효성 검사이다.

**8.7.3 뷰**
- MVC와 마찬가지로, 뷰는 애플리케이션에서 사용자가 상호작용하는 유일한 부분이고, 뷰모델의 상태를 표현하는 상호작용이 가능한 UI이다.
- 뷰는 상태를 관리할 책임이 없다. 뷰는 뷰모델과 정보 또는 상태를 항상 동기화된 상태로 유지하기 때문이다.

**8.7.4 뷰모델**
- 데이터 변환기의 역할을 하는 특수한 컨트롤러이다.
- 모델의 정보를 뷰가 사용할 수 있는 형태로 변환하고, 뷰에서 발생한 명령(사용자의 조작이나 이벤트)을 모델로 전달

**8.7.5 뷰와 뷰모델 복습**
- 뷰와 뷰모델은 데이터 바인딩과 이벤트를 통해 소통한다.
- 뷰모델은 모델의 속성을 단순히 제공하는 것뿐만 아니라, 데이터 유효성 검사 같은 다른 메서드와 기능에 대한 접근도 허용한다.
- 뷰는 자체 UI 이벤트를 처리하고, 필요에 따라 뷰모델에 연결한다.
- 모델과 뷰모델의 속성은 양방향 데이터 바인딩을 통해 동기화되고 업데이트된다.

**8.7.6 뷰모델 vs 모델**
- MVVM에서 뷰모델은 모델에 대해 전적인 책임을 진다.
- 뷰모델은 데이터 바인딩을 위해 모델 또는 모델의 속성을 가져올 수 있고, 뷰에 제공되는 속성을 가져오거나 조작하기 위한 인터페이스를 포함할 수 있다.

### 8.8 장단점
**8.8.1 장점**

① MVVM은 UI와 이를 구동하게 해주는 요소를 동시에 개발할 수 있도록 한다.

② MVVM은 뷰를 추상화함으로써 뷰의 뒤에 작성되는 비즈니스 로직(또는 연결 코드)의 양을 줄여준다.

③ 뷰모델은 이벤트 중심 코드에 비해 단위 테스트가 더 쉽다.

④ 뷰모델은 UI 자동화나 상호작용에 대한 고려 없이도 테스트가 가능한다.

**8.8.2 단점**

① 단순한 UI의 경우, MVVM은 과도한 구현이 될 수 있다.

② 데이터 바인딩은 선언적이고 사용하기 편리할 수 있지만, 단순히 중단점을 성정하는 명령형 코드에 비해 디버깅이 더 어려울 수 있다.

③ 복잡한 애플리케이션에서는, 데이터 바인딩이 상당한 관리 부담을 만들어 낼 수 있다. 또한 바인딩 코드가 바인딩 대상 객체보다 더 무거운 상황이 발생할 수도 있다.

④ 대규모 애플리케이션에서는 필요한 일반화를 제공하기 위해 뷰모델을 미리 설계하는 것이 어려울 수 있다.

### 8.9 MVC vs MVP vs MVVM
⦿ MVC에서는 뷰가 아키텍처의 최상단에 위치하고 그 옆에는 컨트롤러가 있다.
모델은 컨트롤러 아래에 있기 때문에, 뷰는 컨트롤러에 대해 알고 있고, 컨트롤러는 모델에 대해 알고 있다. 이 구조에서는 뷰가 모델에 직접 접근할 수 있다.

⦿ MVP에서는 컨트롤러의 역할이 프리젠터로 대체된다.
프리젠터는 뷰와 동일한 계층에 존재하며, 뷰와 모델 양쪽에서 발생하는 이벤트를 수신하고 이들 간의 동작을 조정한다.

⦿ MVVM은 상태와 로직 정보를 포함할 수 있는 뷰와 관련된 모델 일부를 생성할 수 있다.
MVP의 프리젠터와 달리, 뷰모델은 뷰를 참조할 필요가 없다.

### 8.10 최신 MV* 패턴
- MV* 패턴은 최신 바닐라 자바스크립트로 구현할 수 있다.
- 기술적으로 리액트나 Vue.js와 같은 최신 라이브러리와 프레임워크는 애플리케이션의 뷰 또는 프레젠테이션 계층을 구성한다.

**8.10.1 MV* 패턴과 리액트**
- 리액트는 뷰 계층을 원하는대로 구성하게 해주는 렌더링 라이브러리이다.
- 리액트는 선언형 프로그래밍 방식을 따른다.
- 리액트는 MVC를 기술에 따라 수평적으로 나누는 대신, 관심사에 따라 수직적으로 나눈다.
- 리액트의 컴포넌트는 상태(모델), 렌더링(뷰), 제어 흐름 로직(소규모의 지역화된 컨트롤러)를 담고 있는 작은 수직 분할형 MVC로 시작되었다고 볼 수 있다.
- 많은 컴포넌트 로직이 Hooks로 구성됨에 따라, 컴포넌트를 뷰로, Hooks를 컨트롤러로 볼 수도 있다.

```
(1) MVC의 수평적 분리
→ 기능이 아니라 역할 기준으로 분리

[ Model ] ←→ [ Controller ] ←→ [ View ]


(2) 리액트의 수직 분리
→ 하나의 컴포넌트 안에 모델 + 뷰 + 컨트롤러 역할이 다 같이 있음

[ 컴포넌트 1 ]
  - 로컬 상태 (Model)
  - JSX 렌더링 (View)
  - 이벤트 핸들링 (Controller)

[ 컴포넌트 2 ]
  - ...

```

### 내 생각 💭
Vue.js가 양방향 바인딩을 지원하고, React가 단방향 바인딩을 따른다는 사실은 알고 있었지만, 그 차이가 실제로 어떤 구조적 의미를 가지는지 깊게 고민해본 적은 없었다. 이번 단원을 공부하면서 Vue는 MVVM 패턴을 따르고 있기 때문에 `v-model` 같은 기능으로 상태와 UI가 자동으로 연결되는 구조라는 것을 이해하게 되었다. 반면, React는 특정 아키텍처 패턴을 강제하지 않고, 여러 패턴을 조합할 수 있게 설계된 선언형 UI 라이브러리라는 점을 알게 되었다.

또한 React는 특정 아키텍처 패턴을 정의하지 않고, 다양한 패턴을 유연하게 조합할 수 있도록 설계된 점이 인상 깊었다. 또한 이런 구조 덕분에 MVVM, Pub-Sub, 옵저버 패턴 등의 여러 패턴을 자유롭게 조합할 수 있다는 것을 알게 되었다. 평소 React를 가장 많이 써왔던 기술이었음에도 이번 단원을 통해서 React의 구조적 특징, 철학, 그리고 Vue.js와의 근본적인 차이 등에 대해 깊게 이해할 수 있었다.
